<rss version="2.0">
    <channel>    
        <title>Влад Костянецкий</title>
        <description>Привет! Меня зовут Влад, я — разработчик приложений для бизнеса.</description>
        <language>ru</language>
        <link>https://kostyanetsky.ru</link>
        <lastBuildDate>Sat, 24 Apr 2021 10:00:00 +0700</lastBuildDate>
        
        <item>
            <title>Пучок скриптов</title>
            <link>https://kostyanetsky.ru/notes/bunch-of-scrips/</link>
            <guid isPermaLink="false">note-bunch-of-scrips</guid>
            <pubDate>Sat, 24 Apr 2021 10:00:00 +0700</pubDate>
            <description><p class="measure-wide">Выложил на GitHub ещё несколько скриптов для разбора технологического журнала платформы, которые написал за последнее время:</p>
<ul class="measure-wide">
<li><a class="link blue dim bb" href="https://github.com/vkostyanetsky/ScriptsFor1C/blob/master/Технологический журнал/FrequentEvents.sh">Частотные события</a>. Группирует события по наименованию, считает количество воспроизведений для каждого и выводит в порядке убывания — от наиболее частотного к наименее частотному. Осмысленного практического применения у этого скрипта нет; просто фиксировал для себя, какие события пишет каждый процесс кластера сам по себе.</li>
<li><a class="link blue dim bb" href="https://github.com/vkostyanetsky/ScriptsFor1C/blob/master/Технологический журнал/ExceptionDescriptions.sh">Описания исключений</a>. Группирует EXCP по полю Name; для каждого наименования выводит варианты значений поля Description, которые были у исключений с таким наименованием. С помощью этого скрипта можно составить примерную картину: какие исключения действительно проблема, а какие — просто белый шум, который можно игнорировать и, например, закинуть в фильтры Кибаны.</li>
<li><a class="link blue dim bb" href="https://github.com/vkostyanetsky/ScriptsFor1C/blob/master/Технологический журнал/LocksByConnectIDAndRegions.sh">Блокировки по ID соединения и области</a>. Удобен для поиска виновника таймаута на управляемых блокировках: скрипт выгребает из ТЖ все TLOCK'и по конкретной области от конкретного соединения, а потом выстраивает их в хронологическом порядке.</li>
</ul></description>
        </item>
        
        <item>
            <title>SKUUUID в своем глазу</title>
            <link>https://kostyanetsky.ru/notes/skuuuid/</link>
            <guid isPermaLink="false">note-skuuuid</guid>
            <pubDate>Mon, 22 Feb 2021 17:11:53 +0700</pubDate>
            <description><p class="measure-wide">Пару недель назад Александр Кунташов у себя на канале <a class="link blue dim bb" href="https://t.me/kuntashov_devnotes/479">запостил</a> забавный скрин перечисления из Библиотеки Электронных Документов, создателей которого откровенно манили длинные аббревиатуры. Я бодро острил на тему родства ИППДОИПУПДУКД'а и московского ГНУВНИВИПФИТ'а, а потом увидел в собственном коде вот эту красотку:</p>
<p class="measure-wide"><img alt="SKUUUID" src="https://kostyanetsky.ru/notes/skuuuid/skuuuid.png"/></p>
<p class="measure-wide">Ещё не вполне рука маэстро, конечно, но движение определенно в том же направлении. Вспомнилась притча про сучок в чужом глазу и суковатое бревно — в своём :-)</p></description>
        </item>
        
        <item>
            <title>Проблема с литералом даты при пересчете итогов</title>
            <link>https://kostyanetsky.ru/notes/date-literal-exceeds-3999/</link>
            <guid isPermaLink="false">note-date-literal-exceeds-3999</guid>
            <pubDate>Sat, 06 Feb 2021 19:13:53 +0700</pubDate>
            <description><p class="measure-wide">Итак, в ходе рутинного пересчета итогов из Конфигуратора мы неожиданно получили ошибку «номер года в литерале типа дата превышает 3999». Это значит, где-то в базе есть (или пытается появиться) дата больше, чем предельно допустимая с точки зрения 1С (31.12.3999 23:59:59).</p>
<p class="measure-wide"><img alt="Исключение" src="https://kostyanetsky.ru/notes/date-literal-exceeds-3999/excp.png"/></p>
<p class="measure-wide">Ладно, что с этим делать?</p>
<p class="measure-wide">Главное — выйти на конкретную таблицу с проблемными датами. Ошибка возникла при пересчете итогов, так что очевидно: искать нужно в регистрах. Открываем стандартную обработку управления итогами, делаем пересчет и <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/date-literal-exceeds-3999/totals.png">получаем</a> имя регистра, на котором спотыкается платформа.</p>
<p class="measure-wide">Другой, более методологически правильный подход — настроить сбор ТЖ (SDBL, EXCP и EXCPCNTX) и получить примерно <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/date-literal-exceeds-3999/excp.log">такой</a> лог. Ищем в нём событие EXCP (исключение), а непосредственно перед ним — событие SDBL (SQL-запрос в терминах платформы). Этот запрос — причина сбоя; в его тексте видим имя нужной нам таблицы (AccumRgTn11530). Имя объекта конфигурации для неё можно вытащить любой обработкой, построенной на методе ПолучитьСтруктуруХраненияБазыДанных().</p>
<p class="measure-wide">В общем, так или иначе мы получим имя регистра. Открываем его форму и простой сортировкой по периоду выходим на <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/date-literal-exceeds-3999/entries.png">проблемные движения</a>. Нужно проанализировать документы, которые их сделали, устранить причину ошибки и перепровести документы. Если после этого проблема с пересчетом останется — это либо не единственная таблица с проблемными датами (ищем дальше), либо эти даты успели засесть где-то ещё, кроме таблицы движений.</p>
<p class="measure-wide">Например, у меня был случай, когда после исправления движений записи с некорректными датами сохранялись в таблице оборотов. Средствами платформы их удалить было нельзя, но размер базы позволял играться с реструктуризацией. Я выкинул следующий финт: отключил признак «Использование в итогах» для всех измерений регистра и применил изменения; потом вернул признак на место и пересчитал итоги. В итоге таблица оборотов регистра была физически удалена, а потом создана и наполнена заново — уже без дат на много веков вперёд.</p>
<p class="measure-wide">В крайнем случае можно было удалить проблемные записи с помощью прямых SQL-запросов (DELETE или даже TRUNCATE). Но это, во-первых, нарушает лицензионное соглашение с разработчиками платформы, а во вторых — опасно (по неосторожности можно удалить что-то важное и не заметить). Так что не советую, э-э, повторять в домашних условиях :-)</p></description>
        </item>
        
        <item>
            <title>Определение видимости объекта</title>
            <link>https://kostyanetsky.ru/notes/do-you-see-it/</link>
            <guid isPermaLink="false">note-do-you-see-it</guid>
            <pubDate>Sun, 17 Jan 2021 12:34:45 +0700</pubDate>
            <description><p class="measure-wide">В платформе сразу несколько механик решает, видит пользователь некий объект метаданных или нет. Одна из них — функциональные опции. Если вы раньше не имели с ними дела, в двух словах дела обстоят так: объект можно добавить в состав опции, которая внутри конкретной базы может как быть активной (и видимой пользователям), так и неактивной (и, соответственно, скрытой). Объект можно засунуть в несколько опций сразу (и тогда он отображается, если активна хотя бы одна из них) или не включать вообще никуда (и тогда пользователи его видят в любом случае).</p>
<p class="measure-wide">Так вот, помню, лет пять назад я искал способ понять из кода — видит пользователь объект или нет? Чисто с точки зрения функциональных опций. Тогда я почему-то не нашел решения, а ведь оно до смешного простое; вот, например, <a class="link blue dim bb" href="https://gist.github.com/vkostyanetsky/a6c0525c38a8231f37a676ec240d657a">функция</a> ровно для этого. Логика:</p>
<ol class="measure-wide">
<li>Перебираем опции и ищем объект в составе каждой из них.</li>
<li>Если объект есть в составе опции, проверяем: опция активна? Если да — значит, пользователь видит объект.</li>
<li>Если объект не включен ни в одну опцию — тоже видит.</li>
</ol>
<p class="measure-wide">Конечно, результаты такого анализа как минимум нужно кэшировать (хотя бы из-за запроса в цикле), но в остальном он вполне адекватен. Никак не возьму в толк, почему я тогда не написал что-то похожее? Ох, надеюсь, спустя следующие пять лет мои нынешние занозы в заднице тоже будут отлетать на раз-два-три.</p></description>
        </item>
        
        <item>
            <title>Рекурсивный поиск по файлам</title>
            <link>https://kostyanetsky.ru/notes/recursive-search/</link>
            <guid isPermaLink="false">note-recursive-search</guid>
            <pubDate>Thu, 14 Jan 2021 10:15:16 +0700</pubDate>
            <description><p class="measure-wide">Время назад я <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/vulnerabilities/">примеривался</a> к поискам уязвимостей в коде скриптами на bash (звучит грозно, но это просто рекурсивный поиск текста с помощью регулярных выражений). Скрипты-то я тогда написал, но, как сегодня понял — несколько... Ректально, кхм. Для решения хватает одного egrep! То есть из связки find, xargs и egrep можно выкинуть два компонента из трех.</p>
<p class="measure-wide">Например, сегодня у нас возникла проблема: конфигурация перестала собираться в последнем релизе EDT. Подозрение пало на битые GUID — ссылки на объекты метаданных, удаленные из конфигурации. Платформа не всегда справляется с их вычисткой после того, как удалит сами объекты; я уже пару раз писал про это (например, <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/designer-error-investigation/">здесь</a> или <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/unresolved-gopher/">вот тут</a>).</p>
<p class="measure-wide">В общем, мы решили порыться в выгрузке конфигурации — найти GUID'ы и оценить, все ли они находятся там, где положено. Общее решение — одна-единственная команда:</p>
<pre><code>egrep -rn '.{8}-.{4}-.{4}-.{4}-.{12}' dump
</code></pre>
<p class="measure-wide">Ключ r включает рекурсивный поиск, ключ n — заставляет утилиту пристегнуть к найденной строке не только имя файла, в котором найдена строка, но и номер самой строки. Последний параметр, dump — имя директории, где нужно искать.</p>
<p class="measure-wide">Регулярку можно сделать точнее, но и такой за глаза хватает. Что до ложных срабатываний (то есть GUID, которые не являются битыми ссылками) — их легко отсеять через пайп. Например, скрипт ниже не будет выводить строки с GUID, в которых есть подстрока «uuid»:</p>
<pre><code>egrep -rn '.{8}-.{4}-.{4}-.{4}-.{12}' dump | grep -v 'uuid'
</code></pre></description>
        </item>
        
        <item>
            <title>Старый добрый DATETIME</title>
            <link>https://kostyanetsky.ru/notes/old-but-gold/</link>
            <guid isPermaLink="false">note-old-but-gold</guid>
            <pubDate>Wed, 11 Nov 2020 17:00:50 +0700</pubDate>
            <description><p class="measure-wide">Порылся в сети по поводу типов дат в MS SQL Server и в целом вопроса «почему 1С до сих пор носится со своим смещением» больше не имею. Люди пишут о целой пачке проблем с DATETIME2:</p>
<ol class="measure-wide">
<li>Недоступна базовая математика. Без дополнительных финтов ушами не выйдет посчитать разницу между двумя датами, прибавить к дате день и так далее.</li>
<li>Стандартные функции по-прежнему возвращают старый добрый DATETIME (например, DATEADD). Если данные хранятся в DATETIME2 — потребуется конвертация.</li>
<li>Поля с этим типом <a class="link blue dim bb" href="https://sqlperformance.com/2016/04/sql-performance/surprises-dateadd">неважно</a> индексируются, так как каждое значение DATETIME2 хранится задом наперед (сначала время, потом дата). В итоге СУБД промахивается с оценкой количества строк, которое может вернуть запрос, и строит для него неэффективный план выполнения.</li>
</ol>
<p class="measure-wide">Подробнее о всем этом можно прочитать на <a class="link blue dim bb" href="https://towardsdatascience.com/datetime2-why-you-should-not-use-it-70e50ae2bab9">Towards Data Science</a> или, например, на <a class="link blue dim bb" href="https://www.sqlservercentral.com/forums/topic/why-do-some-dbas-avoid-datetime2">SQL Server Central</a>.</p></description>
        </item>
        
        <item>
            <title>Смещение дат в 1С</title>
            <link>https://kostyanetsky.ru/notes/lost-time/</link>
            <guid isPermaLink="false">note-lost-time</guid>
            <pubDate>Tue, 10 Nov 2020 19:06:41 +0700</pubDate>
            <description><p class="measure-wide">В MS SQL Server поля DATETIME <a class="link blue dim bb" href="https://docs.microsoft.com/ru-ru/dotnet/api/system.data.sqltypes.sqldatetime.minvalue?view=dotnet-plat-ext-3.1">не могут</a> хранить даты раньше 1753-го года. Например, если попытаться записать в базу 01.01.0001 — получим ругань на out-of-range value. Я считал это забавным для такой почтенной СУБД рудиментом, пока случайно не наткнулся на <a class="link blue dim bb" href="https://stackoverflow.com/questions/3310569/what-is-the-significance-of-1-1-1753-in-sql-server">причину</a>.</p>
<p class="measure-wide">Если вкратце, в 1752-м году Великобритания внедрила у себя Григорианский календарь, и в процессе у них из летосчисления пропало одиннадцать дней. Это породило проблему: вот хочет юзер посчитать разницу в днях между 1653-м и 1753-м годом — что делать будем? Учтем потеряшек? Проигнорируем? Сделаем какие-то хинты или настройки?</p>
<p class="measure-wide">Видимо, чтобы не городить неоднозначные механизмы, разработчики СУБД решили вопрос радикально — усечением доступного диапазона дат. А для тех, для кого это проблема, есть DATETIME2, который никаких ограничений не имеет.</p>
<p class="measure-wide">Что касается 1С, то изначально платформа использовала DATETIME, а чтобы не иметь головной боли с хранением дат раньше 1753-го года — придумала специальный <a class="link blue dim bb" href="https://its.1c.ru/db/metod8dev/content/4055/hdoc">костыль</a>. В двух словах: когда платформа пишет даты в БД, то тихой сапой прибавляет к каждой две тысячи лет, а когда читает — вычитает обратно. То есть в 1С пользователь видит 01.01.2000, а в БД на самом деле хранится 01.01.4000.</p>
<p class="measure-wide">Любопытно, почему 1C до сих пор не выкинула эту штуку? Сейчас платформа использует DATETIME2 и фокус по смещением в общем-то не нужен. Конечно, тут могут быть какие-то подводные камни или просто разумная осторожность, но среди разработчиков самой СУБД сомнений <a class="link blue dim bb" href="https://stackoverflow.com/questions/3310569/what-is-the-significance-of-1-1-1753-in-sql-server/3310627#3310627">не заметно</a>:</p>
<blockquote>
<p class="measure-wide">Your great great great great great great great grandfather should upgrade to SQL Server 2008 and use the DateTime2 data type, which supports dates in the range: 0001-01-01 through 9999-12-31.</p>
<p class="measure-wide"><em>Joe Stefanelli (SQL Server developer)</em></p>
</blockquote>
<p class="measure-wide">Возможно, это просто на дне приоритетов. Добавление и удаление двух тысяч лет для каждой даты, конечно, увеличивает нагрузку на оборудование, но на фоне остального она теряется.</p></description>
        </item>
        
        <item>
            <title>Халк удалять!</title>
            <link>https://kostyanetsky.ru/notes/hulk-removes/</link>
            <guid isPermaLink="false">note-hulk-removes</guid>
            <pubDate>Mon, 09 Nov 2020 16:03:07 +0700</pubDate>
            <description><p class="measure-wide">На <a class="link blue dim bb" href="https://postgrespro.ru/education/courses/DBA1">курсе</a> по PostgreSQL узнал смешную деталь: в 10-й версии СУБД разработчики переименовали папку pg_xlog (журналы предзаписи) в pg_wal, а папку pg_clog (статусы транзакций) — в pg_xact.</p>
<p class="measure-wide">Знаете, почему? Из-за не слишком опытных, но уже достаточно смелых администраторов, которые триггерились на слово «log» в названии папки. Мол, мне нужно место на диске освободить, а тут СУБД забила всё своими дурацкими логами. Некогда разбираться, rm -rf их и порядок!</p>
<p class="measure-wide">В общем, в трубу одновременно вылетала и защита работы с данными в буферном кэше, и многоверсионность. После чего кластер умирал в муках. Свободного места на диске получалось много, но радоваться этому, боюсь, приходилось недолго :-)</p></description>
        </item>
        
        <item>
            <title>Время для прогулки</title>
            <link>https://kostyanetsky.ru/notes/time-to-wink/</link>
            <guid isPermaLink="false">note-time-to-wink</guid>
            <pubDate>Mon, 02 Nov 2020 15:36:28 +0700</pubDate>
            <description><p class="measure-wide">Как понять, что надо сделать перерыв в работе? Скажем так: если ваш скрипт внезапно начал вам подмигивать — точно пора проветриться.</p>
<p class="measure-wide"><img alt="Привет!" src="https://kostyanetsky.ru/notes/time-to-wink/wink.png"/></p></description>
        </item>
        
        <item>
            <title>Расследование ошибки в Конфигураторе</title>
            <link>https://kostyanetsky.ru/notes/designer-error-investigation/</link>
            <guid isPermaLink="false">note-designer-error-investigation</guid>
            <pubDate>Sat, 31 Oct 2020 12:38:15 +0700</pubDate>
            <description><p class="measure-wide">Итак, Конфигуратор выдает ошибку; нужно её исправить или обойти. Это потенциально неприятный расклад: у нас нет никакого доступа к коду приложения. Тем не менее, чтобы решить проблему — важно понять, что именно делал Конфигуратор до сбоя и почему он не справился.</p>
<p class="measure-wide">Что может с этим помочь?</p>
<p class="measure-wide">Первое — сам текст ошибки. Нередко его вполне достаточно, чтобы мысли двинулись в правильном направлении. Если причиной сбоя стал запрос, то в ошибке будет ещё и сообщение от СУБД.</p>
<p class="measure-wide">Второе — технологический журнал по событиям EXCP, SDBL и DBMSSQL (DBPOSTGRS?) для t:applicationName=Designer. Из него мы получим информацию об исключениях внутри Конфигуратора и данные запросов, которые он выполняет (нередко они и есть причина ошибки).</p>
<p class="measure-wide">Кроме того, может пригодиться трассировка запросов к базе данных. Если используется MS SQL, то трассировку можно получить через Extended Events — конкретно, нас интересуют события error_reported, rpc_completed и sql_batch_completed. Общий принцип тот же — ловим ошибки выполнения запросов и сами запросы. </p>
<p class="measure-wide">Разберем пример — может, не самый показательный, зато свежий.</p>
<p class="measure-wide">Контекст — конфигурация, использующая <a class="link blue dim bb" href="https://v8.1c.ru/platforma/razdelenie-dannyh/">разделение данных</a>. Её база данных «нарезана» на кусочки (области данных), каждый из которых ничего не знает о своих соседях — сколько их, какого они размера и так далее. При этом в БД есть и общие данные — например, справочники, к которым можно обратиться из любой области. Как правило, это разная техническая информация — например, перечень объектов метаданных.</p>
<p class="measure-wide">Задача — исключить справочник FileStorageVolumes из основного разделителя. Сейчас этот справочник — разделенный: то есть, его данные от области к области будут различаться. Нам нужно сделать так, чтобы содержимое справочника стало одинаковым для всех областей.</p>
<p class="measure-wide">Задача несложная, так как таблица справочника пуста — ни одна из областей ничего в нем не хранит. Что же, применяем <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/designer-error-investigation/setup.png">настройку</a> и:</p>
<p class="measure-wide"><img alt="Исключение" src="https://kostyanetsky.ru/notes/designer-error-investigation/error.png"/></p>
<p class="measure-wide">В <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/designer-error-investigation/error.txt">тексте</a> исключения есть сообщения: одно от платформы, второе от СУБД. Первое озадачивает: то есть как это данные не уникальны? Справочник же пуст, никаких данных нет. Возможно, проблема в каких-то вспомогательных структурах, не связанных с содержимым справочника напрямую.</p>
<p class="measure-wide">Сообщение СУБД более внятное: MS SQL Server хотела создать уникальный индекс для таблицы _DataHistorySettingsNG, но не смогла, так как сочетания индексируемых полей оказались неуникальны. Приводится даже конкретное значение, из-за которого не получилось создать индекс: это NULL.</p>
<p class="measure-wide">Выводы?</p>
<ol class="measure-wide">
<li>Очевидно, что проблема возникла в ходе реструктуризации. Во-первых, именно её мы и делали. Во-вторых, на это указывает и операция CREATE UNIQUE INDEX (создание индексов в таблицах — часть реструктуризации), и название проблемной таблицы: в нём есть постфикс NG (его получают копии таблиц, которые создаются при реструктуризации; если она проходит успешно, то платформа удаляет исходную таблицу и переименовывает копию).</li>
<li>Проблема возникла с настройками механизма истории данных (_DataHistorySettings). Там хранится статус каждого объекта метаданных: нужно или нет вести историю данных для объекта, его полей и полей его табличных частей (если они есть).</li>
</ol>
<p class="measure-wide">Последнее объясняет, почему проблема уникальности возникла на пустом справочнике: настройки истории данных для объекта хранятся независимо от того, есть в объекте какие-то данные или нет. Если посмотреть на таблицу с настройками, там всего три поля: _MetadataId (ID объекта метаданных), _Content (значения настроек) и _Fld626 (разделитель области).</p>
<p class="measure-wide">До реструктуризации данные имеют примерно такой вид:</p>
<p class="measure-wide"><img alt="Таблица _DataHistorySettings" src="https://kostyanetsky.ru/notes/designer-error-investigation/table.png"/></p>
<p class="measure-wide">Однако потом эта картина изменилась. Когда мы исключили справочник из состава общего реквизита, конфигуратор запустил реструктуризацию: создал таблицу _DataHistorySettingsNG, перенес в неё данные из _DataHistorySettings и установил значение поля _Fld626 в NULL всем записям, которые относятся к справочнику FileStorageVolumes.</p>
<p class="measure-wide">К чему это привело? А вот к чему: для справочника FileStorageVolumes появился целый ворох настроек, которые не относятся к какой-либо области. Это само по себе звучит нездорово, но настоящие проблемы начались, когда Конфигуратор попытался создать для таблицы кластерный индекс: он <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/designer-error-investigation/index.png">строится</a> по полям _MetadataId и _Fld626, является уникальным и, соответственно, не может быть создан — в таблице множество записей, у которых различается только поле _Content, а _MetadataId и _Fld626 — гарантированно идентичны.</p>
<p class="measure-wide">Для очистки совести посмотрим <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/designer-error-investigation/20103116.log">техжурнал</a> (я вычистил оттуда нерелевантные события и другую постороннюю информацию). Наши догадки подтверждается: видим, как Конфигуратор создает и заполняет таблицу _DataHistorySettingsNG, пытается проиндексировать её, но получает ошибку и удаляет. В <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/designer-error-investigation/20103116.png">трассировке</a> СУБД примерно та же картина.</p>
<p class="measure-wide">На этом интересное заканчивается, так как решение достаточно очевидно: удаляем настройки истории данных для справочника во всей областях данных и повторяем реструктуризацию. Ошибку это не исправит, конечно; по хорошему, Конфигуратор должен предсказывать такую ситуацию и выдавать адекватное сообщение — как, например, при удалении измерения регистра сведений, которое приводит к нарушению уникальности измерений для записей регистра. Однако задача будет решена.</p>
<p class="measure-wide">В общем, готово — мы великолепны!</p></description>
        </item>
        
    </channel>
</rss>