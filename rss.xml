<rss version="2.0">
    <channel>    
        <title>Влад Костянецкий</title>
        <description>Привет! Меня зовут Влад, я — разработчик приложений для бизнеса.</description>
        <language>ru</language>
        <link>https://kostyanetsky.ru</link>
        <lastBuildDate>Wed, 22 Sep 2021 21:25:48 +0700</lastBuildDate>
        
        <item>
            <title>Diablo</title>
            <link>https://kostyanetsky.ru/notes/diablo/</link>
            <guid isPermaLink="false">note-diablo</guid>
            <pubDate>Wed, 22 Sep 2021 21:25:48 +0700</pubDate>
            <description><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" frameborder="0" height="315" src="https://www.youtube.com/embed/kVd6qeWoAxg" width="560"></iframe>
<p class="measure-wide">Неплохой выпуск айтишного подкаста «Мы обречены» про выгорание разработчиков. Никаких особых откровений, но что-то полезное для себя подчерпнуть можно. Например, взять и не переключиться на пет-проекты после работы, а захлопнуть ноутбук и пойти погулять.</p>
<p class="measure-wide">Очень понравилась аналогия с видеоиграми где-то ближе к середине:</p>
<blockquote>
<p class="measure-wide">Была такая игра — Diablo. Бегаешь ты там, RPG, всякие спеллы. У персонажа есть мана и здоровье, и когда у тебя маны на каст… Ха, звучу как задрот! Ну ладно. В общем, когда у тебя маны на каст не хватает, она у тебя начинает из здоровья браться.</p>
<p class="measure-wide"><em>— Доктор Кот</em></p>
</blockquote></description>
        </item>
        
        <item>
            <title>Про молоток и гвозди</title>
            <link>https://kostyanetsky.ru/notes/hammer-and-nails/</link>
            <guid isPermaLink="false">note-hammer-and-nails</guid>
            <pubDate>Wed, 15 Sep 2021 21:47:48 +0700</pubDate>
            <description><p class="measure-wide">На днях допиливал платежные документы в нашей конфигурации и наткнулся на невероятно избыточное решение примитивной задачи. Простите, не  могу держать в себе.</p>
<p class="measure-wide">Вот есть у вас документ, да? В нём — несколько табличных частей. В каждой — поле для комментария. Делаете вы для этого документа печатную форму; если хотя бы в одной строке любой ТЧ есть комментарий — нужно использовать один шаблон, если комментариев нет — другой.</p>
<p class="measure-wide">Задача примитивная, все мы миллион раз такое делали — ну, смотрим в выборку строк, натравливаем ПустаяСтрока() на нужное поле и грузим подходящий шаблон. Готово, можно пить кофе!</p>
<p class="measure-wide">Однако, вместо короткого цикла я увидел это:</p>
<script src="https://gist.github.com/vkostyanetsky/e870d5bb3d2f23d93f3d17001eaef59b.js">Суть</script>
<p class="measure-wide">Ну то есть да, делаем матрешку из подзапросов, в самом нижнем из которых роемся в ТЧ (которые мы, напомню, только что выгребали для вывода на печатную форму). Ищем в них комментарии, если есть — ставим единичку. Нет? Нолик. Итог несколько раз группируем и возвращаем в скрипт.</p>
<p class="measure-wide">Я сейчас даже не про нагрузку на СУБД (рискну предположить, что заметного эффекта этот трюк не дает — в конце концов, после отбора по ссылке выборка будет копеечной). Просто… Ну… Чекнуть выборку строк — пять строк кода. Понятных, простых, коротких, Сонару ругнуться негде. Как можно было родить вот это? Из большой любви к запросам? </p>
<p class="measure-wide">А ведь что-то в этом духе и было, скорее всего. Я почти вижу его, этого кодера, который только что более-менее сносно освоил запросы и пребывает в перманентном восторге от новых возможностей. А когда в руках есть клёвый блестящий молоток, всё вокруг кажется гвоздями.</p></description>
        </item>
        
        <item>
            <title>Без комментариев</title>
            <link>https://kostyanetsky.ru/notes/no-comment/</link>
            <guid isPermaLink="false">note-no-comment</guid>
            <pubDate>Wed, 08 Sep 2021 00:12:00 +0700</pubDate>
            <description><p class="measure-wide">Сам не заметил, как бросил привычку педантично комментировать каждый метод, с которым приходится работать. Наверняка у этой практики есть какое-нибудь умное название, но мне нет дела, если честно. Я имею в виду стиль, когда описание добавляют к каждому осмысленному блоку кода:</p>
<script src="https://gist.github.com/vkostyanetsky/afae4dee09d639f34156d6c02b29c2a5.js">Суть</script>
<p class="measure-wide">Смысл тут простой: когда копаешься в каком-нибудь дремучем легаси и бегаешь туда-сюда между хаотично раскиданными процедурами на три экрана каждая — логику каждой из них держать в голове довольно трудно. Первая же чашка кофе всё смоет. Поэтому такие заметки на полях здорово ускоряют ориентацию на местности, и чем больше времени проходит между подходами к коду — тем заметнее эффект.</p>
<p class="measure-wide">Однако в какой-то момент стало понятно, что это ноу-хау — просто костыль, подпирающий откровенно хреновый дизайн кода. Попалась тебе длинная процедура или функция — вздохни, сядь и нарежь толстяка на методы поменьше. Сэкономишь и время, и нервы, и в коде разберешься быстрее, и Сонар порадуешь.</p></description>
        </item>
        
        <item>
            <title>Медленное оповещение</title>
            <link>https://kostyanetsky.ru/notes/slow-notification/</link>
            <guid isPermaLink="false">note-slow-notification</guid>
            <pubDate>Wed, 18 Aug 2021 20:03:30 +0700</pubDate>
            <description><div class="blog-embedded-tweet" data-tweet-id="1427626118635470866"><a class="link blue dim bb" href="https://twitter.com/iamhellcat/status/1427626118635470866" target="_blank">Твит</a></div>
<p class="measure-wide">Прочитал этот твит и внезапно вспомнил случай из практики. Прилетает запрос от клиента — мол, 1С тормозит, сделайте что-нибудь. Уточняем: тормозит всё-таки не вся 1С, а конкретная операция.</p>
<p class="measure-wide">База клиента — переписанная УТ, проблемная операция — из блока доработок. Внутри — множество многоэтажных запросов, возня с таблицами значений, какие-то невнятные вычисления и пачка серверных процедур по семьсот строк каждая. Копию базы снять нельзя, ТЖ недоступен, доступ к СУБД закрыт, доступ к счётчикам — тоже. Отладка на сервере 1С выключена, включить — не вариант.</p>
<p class="measure-wide">Бардак, в общем. Как понять, где тут всё вязнет? Ладно, конфигурацию можно менять — уже неплохо. Вешаю на операцию замер: ну да, думает над чем-то пару минут. Отлично! Потираю ручки и сужаю область поиска: докидываю целый ворох замеров на самые подозрительные участки.</p>
<p class="measure-wide">Результат любопытный: тормозов нет! Код не то чтобы летает, но о минутах и речи нет — с учетом сложности, расходы в пределах допустимого. Может, какая-то сериализация данных между клиентом и сервером? Тщательно выверяю код серверной процедуры — нет, никакой трансляции. Всё, что было на сервере, осталось на сервере.</p>
<p class="measure-wide">Перехожу к клиентской части. Что тут может тормозить-то?.. Выглядел код, упрощая, как-то так:</p>
<script src="https://gist.github.com/vkostyanetsky/df0b17526991bbac3b3df1c75dfa154f.js">Суть</script>
<p class="measure-wide">Смотрел я на этот код, как баран, минут десять. В конце концов спросил коллегу и он рассказал удивительную вещь: оказывается, Оповестить() не просто рассылает оповещения во все открытые формы, а <strong>ждёт</strong>, когда в них завершится обработчик оповещения.</p>
<p class="measure-wide">Я знатно офигел, полез проверять и в конце концов наткнулся на форму, которая ловила событие выполнение операции и подрывалась обновлять свои динамические списки. Запрос в одном из них и давал тормоза (там подзапрос к подзапросу к подзапросу и ворох соединений «через точку» — в общем, дальше не интересно).</p>
<p class="measure-wide">Такая вот яломиште :-) Оповещайте с осторожностью!</p></description>
        </item>
        
        <item>
            <title>Умер Павел Чистов</title>
            <link>https://kostyanetsky.ru/notes/pavel-chistov-passed-away/</link>
            <guid isPermaLink="false">note-pavel-chistov-passed-away</guid>
            <pubDate>Sun, 01 Aug 2021 08:11:19 +0700</pubDate>
            <description><p class="measure-wide">Павел Чистов в пятницу вечером умер из-за сердечной недостаточности. Если вы не знаете, кто это — вот <a class="link blue dim bb" href="https://infostart.ru/journal/news/news/ushel-iz-zhizni-pavel-chistov_1490373/" target="_blank">некролог</a>. Впрочем, раз вы читаете этот блог — скорее всего, знаете.</p>
<p class="measure-wide"><a class="link blue dim bb" href="https://t.me/nixel2007_thoughts/205" target="_blank">Никита Грызлов</a>, <a class="link blue dim bb" href="https://t.me/ilyaleontyevpro1c/38946" target="_blank">Илья Леонтьев</a> и <a class="link blue dim bb" href="https://t.me/cio2cdto/514" target="_blank">Сергей Горшенин</a> собирают деньги для помощи семье Павла. Кроме того, номер карты его вдовы есть в конце некролога по ссылке выше.</p>
<p class="measure-wide">Берегите себя, пожалуйста.</p></description>
        </item>
        
        <item>
            <title>Поиск долгих запросов с помощью Python</title>
            <link>https://kostyanetsky.ru/notes/longest-queries-using-python/</link>
            <guid isPermaLink="false">note-longest-queries-using-python</guid>
            <pubDate>Sun, 18 Jul 2021 17:23:55 +0700</pubDate>
            <description><p class="measure-wide">Выложил <a class="link blue dim bb" href="https://github.com/vkostyanetsky/ScriptsFor1C/blob/master/Технологический журнал/LongestQueries.py" target="_blank">скрипт на Python</a> для поиска длительных запросов в ТЖ 1С. Накатал его в приступе отчаяния: никак не мог понять, почему мой <a class="link blue dim bb" href="https://github.com/vkostyanetsky/ScriptsFor1C/blob/master/Технологический журнал/LongestQueries.sh" target="_blank">верный баш</a> для одного из запросов выдаёт среднее время выполнения больше максимального.</p>
<p class="measure-wide">Как выяснилось, проблема была в gawk. Для некоторых событий ТЖ эта утилита не могла определить длительность: пыталась преобразовать строку в число, фейлилась и… Нет, что вы! Конечно, не кидалась исключением! Просто невозмутимо считала эти строки за ноль и ехала дальше.</p>
<p class="measure-wide">Патч, кстати, вышел ещё глупее проблемы: я просто <a class="link blue dim bb" href="https://github.com/vkostyanetsky/ScriptsFor1C/commit/946f271d6ea0c1e618b180cee11ae91ce4632c18" target="_blank">сделал</a> явное преобразование строки в число, и всё заработало как надо. Чем, блин, явное преобразование в мире gawk'а отличается от неявного? И, главное, почему?</p>
<p class="measure-wide">Короче, цирк уехал, новый скрипт остался. Впрочем, он бережнее расходует память и процессор: в скрипте на баше для расчёта количества выполнений запроса, суммарного времени выполнения и максимального времени одного выполнения я использовал три коллекции, у каждой из которых ключом был текст запроса и его контекст. Соответственно, все три нужно было обновлять и держать в памяти.</p>
<p class="measure-wide">Это вполне рабочая тактика, пока входящий поток не переваливает за сотни тысяч элементов: где-то тут мы начинаем терять гигабайты ОЗУ на хранении коллекций и прорву времени процессора на поиске в них. Новый скрипт попрямее: коллекция одна, но хранит всe данные по каждому запросу.</p></description>
        </item>
        
        <item>
            <title>Почему не баш?</title>
            <link>https://kostyanetsky.ru/notes/why-not-bash/</link>
            <guid isPermaLink="false">note-why-not-bash</guid>
            <pubDate>Sat, 03 Jul 2021 21:31:48 +0700</pubDate>
            <description><p class="measure-wide">В прошлой заметке я говорил о задачах, для решения которых баш — идеальный инструмент: минимум ограничений, простые условия — и оговорился, что иногда он вообще не справляется.</p>
<p class="measure-wide">Чтобы не быть голословным, давайте пример из практики. Есть, скажем, порядка семидесяти гигабайт логов ТЖ 1С, по которым нужно построить топ пояснений к исключениям — от самых частотных к менее частотным.</p>
<p class="measure-wide">Плёвое дело, верно? Выгребаем EXCP, извлекаем Descr, считаем повторения. Даже нужный <a class="link blue dim bb" href="https://github.com/vkostyanetsky/ScriptsFor1C/blob/master/Технологический журнал/FrequentExceptions.sh" target="_blank">скрипт</a> я как-то уже писал. Запускаю, терпеливо жду…</p>
<p class="measure-wide">Знаете, сколько понадобилось времени? Я тоже нет: после того, как скрипт проработал сутки, я его вырубил и полез разбираться, в чём проблема. Затык возник где-то в скрипте gawk'а: именно она активно нагружала процессор (если не считать cat'а, которая время от времени читала очередную порцию данных).</p>
<p class="measure-wide"><img alt="Процессы" src="https://kostyanetsky.ru/notes/why-not-bash/procexp64.png"/></p>
<p class="measure-wide">Беда, беда, огорчение! В общем, я подумал и <a class="link blue dim bb" href="https://github.com/vkostyanetsky/ScriptsFor1C/blob/master/Технологический журнал/FrequentExceptions.py" target="_blank">переписал</a> этот скрипт на Питоне. Новая версия отработала за 15 минут и дала мне:</p>
<ol class="measure-wide">
<li>Топ пояснений по событиям исключений;</li>
<li>Скрипт, который можно прочитать через полгода без помощи гугла;</li>
<li>Уверенность, что я могу добавить в скрипт два-три условия и не вызвать Сатану случайным сочетанием операторов и ключей.</li>
</ol>
<p class="measure-wide">Конечно, я мог оптимизировать версию на баше. Вероятно, тормозит поиск в массиве — время, необходимое для поиска пояснения в массиве уже зафиксированных пояснений, линейно растет с увеличением размера массива. Можно, например, попробовать изменить подход к сбору данных — gawk'ом только извлекать сами пояснения, а результат сбора передать в тандем sort &amp; uniq.</p>
<p class="measure-wide">Однако это уже отчётливо отдаёт <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/why-not-bash/but-why.jpg" target="_blank">мемасом</a> про буханку хлеба: из неё, конечно, можно сделать троллейбус, просто не очень понятно — зачем? Камон, мне бы проблему решить. А Питон с ней уже справился на твердую пятёрку, чем сэкономил мне кучу времени и нервов.</p>
<p class="measure-wide">Собственно, к этому я вел. Родовые травмы баша понятны и нередко приемлемы, плюсы — приятны и очевидны, но при работе с ним вопрос иногда встает так: cтоит ли только ради того, чтобы получить решение именно на баше, потратить часа два на возню с утилитами, параметрами, мануалами и постами на Stack Overflow? </p>
<div class="blog-embedded-tweet" data-tweet-id="1408560771877965825"><a class="link blue dim bb" href="https://twitter.com/EffinBirds/status/1408560771877965825" target="_blank">Твит</a></div>
<p class="measure-wide">Вот поэтому не баш, да.</p></description>
        </item>
        
        <item>
            <title>Почему баш?</title>
            <link>https://kostyanetsky.ru/notes/why-bash/</link>
            <guid isPermaLink="false">note-why-bash</guid>
            <pubDate>Wed, 23 Jun 2021 22:24:48 +0700</pubDate>
            <description><p class="measure-wide">Периодически вижу вопросы коллег: а что, 1С всё ещё носится с башем, да? А чё не питон-то? Или павершелл, на худой конец? Вот чудаки!</p>
<p class="measure-wide">Да, баш не родной для Windows (которая, напротив, родная для 1С) и притащить его туда — отдельная история; да, при усложнении задачи читаемость скрипта падает по экспоненте; да, с некоторыми задачами баш просто не справляется.</p>
<p class="measure-wide">Однако главный плюс баша в том, что для многих задач по анализу ТЖ 1С он — самое простое и быстрое решение. Как старая отвертка, которой ещё дед пользовался. Она всегда под рукой — пусть поцарапанная, с зазубринами и слегка корявая, но всё еще прекрасно работает.</p>
<p class="measure-wide">Пример? Допустим, нужно выгрести из ТЖ исключения; простоты ради договоримся, что достаточно первой строки каждого события. Получим <a class="link blue dim bb" href="https://gist.github.com/vkostyanetsky/f95b30e2f09edd64d9e7a39575bb289a" target="_blank">примерно такой</a> скрипт на питоне. </p>
<p class="measure-wide">Скажете, его можно легко сократить вдвое? А то и втрое. В конце концов, мы решаем локальную задачу. Возня с читаемостью и предсказуемостью тут ни к чему.</p>
<p class="measure-wide">Согласен! Но давайте сначала решим ту же задачу на баше:</p>
<pre><code>grep -r --include "*.log" ',EXCP,' &gt; result.txt
</code></pre>
<p class="measure-wide">Вот почему баш.</p></description>
        </item>
        
        <item>
            <title>Метаданные не найдены</title>
            <link>https://kostyanetsky.ru/notes/metadata-not-found/</link>
            <guid isPermaLink="false">note-metadata-not-found</guid>
            <pubDate>Tue, 08 Jun 2021 17:12:05 +0700</pubDate>
            <description><p class="measure-wide"><img alt="Метаданные не найдены" src="https://kostyanetsky.ru/notes/metadata-not-found/error-ru.png"/></p>
<p class="measure-wide">Думаю, с этой ошибкой мало кто сталкивался. Для этого, во-первых, нужно работать со встроенной в платформу историей данных, а она не больно-то популярна: кто-то привязан к БСП (она пока использует привычное всем версионирование на регистрах сведений), кому-то не нравится реализация — там и правда не всё гладко с точки зрения производительности.</p>
<p class="measure-wide">Во-вторых, нужно сделать так: выключить историю данных для объекта метаданных, а потом грохнуть накопленные версии объектов <strong>до того</strong>, как новые изменения объекта перекочуют из буфера в основную таблицу.</p>
<p class="measure-wide">В двух словах о том, как вообще работает история данных. По дефолту она выключена, и достаточно привилегированный пользователь может включить её для нужных ему объектов — констант, справочников, документов и так далее. После этого при изменении данных в этих объектах платформа будет фиксировать, что именно меняется. Делает она это в два этапа: сначала — относительно быстрая запись в промежуточный буфер (таблицу _DataHistoryQueue0); потом, при вызове метода ОбновитьИсторию(), информация мигрирует в основное хранилище версий (таблицу _DataHistoryVersions) и становится доступна в интерфейсе приложения.</p>
<p class="measure-wide">Обновление истории можно делать сразу при записи, но для сокращения транзакции его обычно выносят в регламентное задание. В итоге миграция данных из буфера в основную таблицу происходит с некоторой периодичностью: например, раз в пять минут. Так вот, если между изменением данных объекта и обновлением истории данных выключить историю объекта и удалить его версии — метод ОбновитьИсторию() выкинет исключение: он попытается переместить изменения из буфера в основную таблицу, но не сможет привязать их к уже накопленным данным.</p>
<p class="measure-wide">Для наглядности — <a class="link blue dim bb" href="https://gist.github.com/vkostyanetsky/ca766fe281425953e0e2bbfe12fc70e2" target="_blank">рабочий код</a>, воспроизводящий проблему для справочника Items на платформе 8.3.17.1989. Можете подставить любой другой объект, с которым работает история данных — разницы нет. </p>
<p class="measure-wide"><strong>Как избежать этой ошибки?</strong> Ну, очевидно: метод ОбновитьИсторию() нужно вызывать непосредственно перед тем, как отключать историю для объекта. Лучше всего делать это в период, когда пользователи с системой не работают: есть риск, что между обновлением истории и её выключением вклинятся чьи-то транзакции, которые спровоцируют ту же проблему. Для гарантии можно использовать монопольный режим.</p>
<p class="measure-wide">Ещё в голову приходит исключительная блокировка на таблицу объекта, но документация не советует вызывать метод ОбновитьИсторию() внутри транзакций — так что тут я не уверен.</p>
<p class="measure-wide"><strong>Как исправить эту ошибку?</strong> Включите историю данных для проблемного объекта, обновите историю и выключите её обратно. Выйдите, так сказать, из класса и зайдите нормально.</p></description>
        </item>
        
        <item>
            <title>Скрипт для синхронизации c NAS</title>
            <link>https://kostyanetsky.ru/notes/rclone-abuser/</link>
            <guid isPermaLink="false">note-rclone-abuser</guid>
            <pubDate>Mon, 07 Jun 2021 19:04:48 +0700</pubDate>
            <description><p class="measure-wide">Выложил на GitHub <a class="link blue dim bb" href="https://github.com/vkostyanetsky/RCloneAbuser" target="_blank">скрипт</a> на Python, который я использую для синхронизации файлов между своим компьютером и домашним NAS'ом. У меня стоит Synology DS220j; с ним так-то идет целый вагон софта и в том числе утилита, которая умеет гонять файлы туда-сюда по расписанию. Однако сделана она, похоже, чисто для галочки: программа принялась глючить ещё на этапе настройки, после чего доверие к ней я потерял.</p>
<p class="measure-wide">В общем, какое-то время я помучался с решениями конкурентов и в итоге вернулся к привычному <a class="link blue dim bb" href="https://rclone.org" target="_blank">rclone</a>, с которым было всего две проблемы. Во-первых, нельзя нормально соединиться с SMB-шарой: да, логин и пароль можно сохранить в Windows и rclone будет их использовать, но они будут слетать при каждом удобном случае. Я вышел из положения, подключив шару как внешний диск.</p>
<p class="measure-wide">Во-вторых, файлов и папок для синхронизации у меня оказалось много: директория здесь, директория там, конфиг оттуда, профиль отсюда… Чтобы не плодить лапшу, я накатал простой скрипт, который берет из конфига источники и приемники, а потом для каждого вызывает rclone по одному и тому же шаблону.</p></description>
        </item>
        
    </channel>
</rss>