<rss version="2.0">
    <channel>    
        <title>Влад Костянецкий</title>
        <description>Привет! Меня зовут Влад, я — разработчик приложений для бизнеса.</description>
        <language>ru</language>
        <link>https://kostyanetsky.ru</link>
        <lastBuildDate>Sat, 08 Jun 2024 18:28:35 +0700</lastBuildDate>
        
        <item>
            <title>Не уникальные метаданные</title>
            <link>https://kostyanetsky.ru/notes/data-history-duplication</link>
            <guid isPermaLink="false">note-data-history-duplication</guid>
            <pubDate>Sat, 08 Jun 2024 18:28:35 +0700</pubDate>
            <description><p>В очередной раз столкнулся с противным багом, при котором платформа ломает таблицу с метаданными истории данных. </p>
<p>Внешне он выглядит так: вы обновляете конфигурацию базы, и при попытке реструктуризации выскакивает ошибка "Таблица метаданных истории данных cодержит не уникальные записи, которые должны быть удалены". </p>
<p>При этом платформа не предлагает никакого понятного способа найти такие записи — иди туда, не знаю куда, сделай то, не знаю что.   </p>
<p><img alt="Таблица метаданных истории данных cодержит не уникальные записи, которые должны быть удалены" src="https://kostyanetsky.ru/notes/data-history-duplication/error.png"/></p>
<p>Проблему можно решить, порывшись в базе данных. Таблица, на которую ссылается ошибка — _DataHistoryMetadata. В ней лежат версии метаданных каждого объекта, для которого ведётся история. Это позволяет платформе понимать, какие реквизиты были у объекта на любой момент времени, в течении которого для объекта велась история.</p>
<p>Как это работает? Ну, когда меняется состав реквизитов объекта (например, реквизит в справочнике добавили), платформа запоминает его метаданные: конкретно, добавляет в _DataHistoryMetadata новую запись и сохраняет в ней актуальный список реквизитов объекта, а также номер версии этого списка (например, в при включении истории для объекта сохраняется первая версия метаданных, при добавлении какого-нибудь реквизита — вторая и так далее).</p>
<p>Ещё платформа ставит в созданной записи отметку, что именно эта версия объекта — самая актуальная, после чего снимает этот флаг со всех других версий метаданных этого объекта.</p>
<p>Так вот, проблема в том, что платформа иногда забывает сделать последний шаг и две версии одновременно становятся актуальными. Она понимает это, но сделать уже ничего не может. </p>
<p><img alt="Как помочь больной скотине?" src="https://kostyanetsky.ru/notes/data-history-duplication/howto.jpeg"/></p>
<p>Решение вытекает из алгоритма выше: нужно найти конфликтующие версии и отобрать признак актуальности у той, что старше. Лучше использовать запросы: история данных, как правило, включается для множества объектов, состав их реквизитов постоянно меняется — в общем, версий в таблице будет столько, что черт ногу сломит.</p>
<p>Если вы тоже столкнулись с этой проблемой и поэтому читаете этот текст — можете воспользоваться <a href="https://gist.github.com/vkostyanetsky/6496c67e2b2fd3d064c4cafd16da0b79" target="_blank">запросами</a>, что написал я:</p>
<ol>
<li>get-issues.sql проверяет, что проблема есть: ищет версии метаданных, которые одновременно помечены как актуальные.</li>
<li>fix-issues.sql снимает признак актуальности с тех версий, которые на самом деле устарели.</li>
</ol>
<p>Оба запроса написаны для Microsoft SQL Server. Если вы используете PostgreSQL, то <a href="https://gist.github.com/vkostyanetsky/75665ce04247e900743604eb386d1889" target="_blank">вот они же</a> для этой СУБД.</p>
<p>Обратите внимание, что запросы потребуют небольшой адаптации под конкретную базу: в них используется поле _fld626, в котором хранится разделитель данных. В вашем случае это поле может называться иначе, поэтому перед выполнением запросов нужно заменить это поле на то, которое есть в вашей таблице _DataHistoryMetadata. Ошибиться будет трудно — у неё только одно поле с префиксом _fld.</p>
<p>P.S. Напоминаю, что лицензионное соглашение запрещает ковыряться в базе данных в обход средств платформы, так что на такие эксперименты можно идти, только если других вариантов не осталось.</p></description>
        </item>
        
        <item>
            <title>Главная проблема UUID</title>
            <link>https://kostyanetsky.ru/notes/uuid-main-issue</link>
            <guid isPermaLink="false">note-uuid-main-issue</guid>
            <pubDate>Sun, 02 Jun 2024 23:18:48 +0700</pubDate>
            <description><p>Наткнулся на <a href="https://www.cybertec-postgresql.com/en/unexpected-downsides-of-uuid-keys-in-postgresql/" target="_blank">хороший текст</a> об основной проблеме, которую таскает с собой UUID. Для 1С она тоже актуальна: все ссылочные объекты платформы (элементы справочников, документы и так далее) имеют собственные UUID. Они хранятся в БД, активно используются при поиске и, понятно, обильно индексируются (со всеми вытекающими последствиями). </p>
<p>1С старается компенсировать проблему, создавая последовательные UUID. Пусть не идеально, но в целом эта штука работает и индексы получаются более-менее ровными. Да и вообще в сообществе об этом говорят довольно давно: вот, например, бородатый <a href="https://forum.mista.ru/topic.php?id=801986" target="_blank">топик на Мисте</a> (правда, тут диалог быстро перерос в курятник и из шести десятков комментариев от силы полтора — по делу).</p>
<p>P.S. Рассмешила ремарка про вероятность создать в одной базе два одинаковых UUID:</p>
<blockquote>
<p>As an aside, for those worried about collisions: you should take up the lottery, since winning the jackpot twice in a row is a much more likely outcome than your system ever generating two identical random 128 bit numbers.</p>
</blockquote></description>
        </item>
        
        <item>
            <title>Скриншот со звуком</title>
            <link>https://kostyanetsky.ru/notes/last-resort</link>
            <guid isPermaLink="false">note-last-resort</guid>
            <pubDate>Mon, 20 May 2024 00:03:07 +0700</pubDate>
            <description><p>Недавно в компании родилась идея разделить внутреннюю ERP-шку на несколько независимых частей и организовать между ними обмен данными. Мы обсудили контуры задачи, модель обмена, транспорт, примерно подбились по срокам — в общем, привычная рутина.</p>
<p>Создал под весь этот огород задачу. Названия им мы даем на английском языке, так что вписал первую формулировку, которая пришла в голову.</p>
<p><img alt="Cut My Life Into Pieces" src="https://kostyanetsky.ru/notes/last-resort/last-resort.png"/></p>
<p>Заголовок вышел со звуком. Ладно, думаю, смешно, но как тогда назвать? Во, пусть будет Distributed Internal ERP. Сокращенно... DIE?</p>
<p>Оставил первый вариант. Long live Papa Roach :)</p></description>
        </item>
        
        <item>
            <title>Таймшит для Обсидиана</title>
            <link>https://kostyanetsky.ru/notes/obsidian-timesheet</link>
            <guid isPermaLink="false">note-obsidian-timesheet</guid>
            <pubDate>Sun, 12 May 2024 17:50:58 +0700</pubDate>
            <description><p>Написал ещё один плагин к <a href="https://obsidian.md" target="_blank">Obsidian</a>, на этот раз — для <a href="https://help.obsidian.md/Plugins/Daily+notes" target="_blank">ежедневных заметок</a>. Рисует симпатичный отчет: над какими задачами работал, что сделал, сколько времени потратил. Я постарался описать в <a href="https://github.com/vkostyanetsky/ObsidianTimesheet" target="_blank">репозитории</a>, как это работает; буду рад, если кому-то ещё пригодится!</p>
<p>Забавный момент: для примеров в README я использовал номера задач FBI-1, FBI-2 и так далее. Это не отсылка к X-Files или Twin Peaks — просто первое, что пришло мне в голову. Дело в том, что наш внутренний проект по разработке FirstBit ERP называется First Bit Internal, сокращенно — FBI. Основной пул задач, над которыми мы работаем, живёт именно в нём.</p>
<p>Мы-то уже привыкли, но коллег вне компании наши скриншоты из JIRA или SonarQube неизменно веселят. Представили, что вы — агент Купер? А мне и представлять не надо :)</p></description>
        </item>
        
        <item>
            <title>Запросом больше, запросом меньше</title>
            <link>https://kostyanetsky.ru/notes/payment-terms</link>
            <guid isPermaLink="false">note-payment-terms</guid>
            <pubDate>Sun, 05 May 2024 21:25:48 +0700</pubDate>
            <description><p>Регулярно слышу тейк: запросом больше, запросом меньше — без разницы. Мол, главное, чтобы запрос был дешевым: не читал лишнего, попадал в индекс и так далее.</p>
<p>Эта точка зрения имеет право на жизнь, однако бездумно пулеметить запросами — опасная затея. Даже если в моменте все выглядит хорошо, в будущем система может слегка поменяться. А потом внешне безобидный патч положит вам прод в пятницу.</p>
<p>Пример из недавней практики. Есть ERP, в которой лежит таблица с этапами оплаты по заказам клиентов. Один из таких этапов — предоплата; пока она не внесена, создать заказ поставщику нельзя. </p>
<p>Технически в заказе поставщику просто хранится ID заказа клиента; если последний заполнен (то есть, заказ поставщику создан под заказ клиента), ERP нужно прочитать этапы оплаты по заказу клиента и понять, можно ли делать закупку. </p>
<p>Звучит элементарно, однако мониторинг показывает: операция тормозит и жрет память, будто в последний раз. Лезем разбираться. Видим примерно такую картинку:</p>
<p><img alt="825701 записей" src="https://kostyanetsky.ru/notes/payment-terms/payment-terms.png"/></p>
<p>То есть вместо того, чтобы выдернуть два-три этапа оплаты по заказу, ERP читает без малого миллион! Как так? </p>
<p>Опуская детали: проблема рождалась в тех заказах поставщику, которые вообще не были связаны с заказом клиента. Разработчик посчитал, что для них можно не менять логику: ID заказа клиента пустой и запрос не найдет для него этапов оплаты. А значит, получится тот же результат, как если бы запроса вообще не было. А лишний запрос — ну... Запросом больше, запросом меньше... Тоже мне, большое дело.</p>
<p>Оказалось, большое. В таблице этапов оплаты оказались данные не только для заказов клиентов, но и для других видов документов. Поле с ID заказа клиента у них было пустым. В итоге ERP при попытке найти этапы оплаты по пустому ID заказа клиента находила такие записи — и, как видите, немало.</p>
<p>Запрос читал порядка гигабайта данных и помещал во временную таблицу. Гигабайт прочитали, гигабайт записали... История била и по диску, и по буферному кэшу СУБД, и по другим частям системы (вплоть до сети, которой этот гигабайт приходилось гонять туда-сюда без всякой пользы).</p>
<p>В общем, знаете, что я думаю? Если результат запроса известен — наверное, его все-таки не нужно делать.</p></description>
        </item>
        
        <item>
            <title>Фудиари для Обсидиана</title>
            <link>https://kostyanetsky.ru/notes/obsidian-foodiary</link>
            <guid isPermaLink="false">note-obsidian-foodiary</guid>
            <pubDate>Sun, 14 Apr 2024 22:36:58 +0700</pubDate>
            <description><p>Вслед за <a href="https://kostyanetsky.ru/notes/obsidian-fastimer" target="_blank">первым</a> плагином для Obsidian пару недель назад выкатил <a href="https://github.com/vkostyanetsky/ObsidianFoodiary" target="_blank">второй</a>. Считает КБЖУ (калории, белки, жиры и углеводы) в пище. Помогает не переедать на пустом месте — всё-таки на глаз трудно оценить, сколько слопал за день, и можно ли позволить себе вон тот пончик.</p>
<p>Короче, полезная штука, если вы:</p>
<ol>
<li>Толстяк (как я)</li>
<li>Хотите перестать им быть (как я)</li>
<li>Ведете заметки в Obsidian (как я) 🙂</li>
</ol>
<p>На самом деле, программ для этой задачи полным-полно (я перепробовал штук десять). Остался недоволен: либо страшная, либо глючит, либо постоянно пытается всучить ежемесячную подписку. Короче, больше раздражает, чем помогает. Хочется чего-то нативного, встроенного в обычную рутину — и если она оседает в Obsidian, то решение напрашивается само собой.</p>
<p>Установить плагин можно прямо из программы — разработчики его уже одобрили. В остальном всё просто: пишем в ежедневной заметке, что съели и сколько это весило, и в ответ получаем компактную табличку с сортировкой по калориям и числам по белкам, жирам и углеводам. </p>
<p>В репозитории по ссылке выше есть примеры.</p></description>
        </item>
        
        <item>
            <title>Внешний вид Фастаймера</title>
            <link>https://kostyanetsky.ru/notes/callouts-for-fastimer</link>
            <guid isPermaLink="false">note-callouts-for-fastimer</guid>
            <pubDate>Sat, 09 Mar 2024 17:44:32 +0700</pubDate>
            <description><p>Завернул отрисовку <a href="https://kostyanetsky.ru/notes/obsidian-fastimer" target="_blank">Фастаймера</a> через выноски: это механика Obsidian, позволяющая превращать обычную цитату в оформленный блок текста, привлекающий внимание читателя. Вы наверняка видели блоки в духе «совет» и «обрати внимание» — вот это и есть выноски. </p>
<p>Подробнее можно прочитать в <a href="https://help.obsidian.md/Editing+and+formatting/Callouts" target="_blank">справке</a> Obsidian.</p>
<p>В общем, теперь таймер принимает разный цвет в зависимости от состояния (активный интервал — голубой, успех — зеленый, провал — красный). Кроме того, я немного уплотнил текст и отточил формулировки:</p>
<p><img alt="Пример" src="https://kostyanetsky.ru/notes/callouts-for-fastimer/example.png"/></p>
<p>Получилось компактнее и симпатичнее простого блока текста, который я использовал до этого.</p></description>
        </item>
        
        <item>
            <title>Маленькие радости</title>
            <link>https://kostyanetsky.ru/notes/small-pleasures</link>
            <guid isPermaLink="false">note-small-pleasures</guid>
            <pubDate>Wed, 06 Mar 2024 21:22:43 +0700</pubDate>
            <description><p>Скучаю в очереди на кассу супермаркета: вечер, покупателей уже не очень много, но пожилая кассирша явно устала и не слишком торопится. Стоящий впереди высокий, седой мужчина с роскошной бородой коротает время, изучая стойку с шоколадками рядом с кассой. </p>
<p>Наконец, берет «Сникерс», задумчиво крутит его в руках. Пододвигает себе ещё два и широко, с видимым удовольствием улыбается в усы :)</p></description>
        </item>
        
        <item>
            <title>Не только лишь все</title>
            <link>https://kostyanetsky.ru/notes/not-only-everything</link>
            <guid isPermaLink="false">note-not-only-everything</guid>
            <pubDate>Sun, 25 Feb 2024 22:49:48 +0700</pubDate>
            <description><p>Завидной глубины комментарий из документации к методу WriteJSON() XDTOSerializer'а:</p>
<p><img alt="Не только лиь все" src="https://kostyanetsky.ru/notes/not-only-everything/write-json.jpg"/></p>
<p>Ну да, метод дампит данные в JSON, а не в XML. Так что поспорить сложно, не все типы данных можно упаковать в XML с его помощью (если быть точным — никакие). Если бы дальше не пошла очевидная копипаста из справки к WriteXML() — счёл бы пасхалкой от разработчиков :)</p></description>
        </item>
        
        <item>
            <title>Фастаймер для Обсидиана</title>
            <link>https://kostyanetsky.ru/notes/obsidian-fastimer</link>
            <guid isPermaLink="false">note-obsidian-fastimer</guid>
            <pubDate>Tue, 13 Feb 2024 01:08:58 +0700</pubDate>
            <description><p>Разработчики <a href="https://obsidian.md" target="_blank">Obsidian</a> на днях заапрувили один из моих пет-плагинов на TypeScript — <a href="https://github.com/vkostyanetsky/ObsidianFastimer" target="_blank">Фастаймер</a>, трекер интервального голодания. Он добавляет в хранилище новый блок кода: вводишь в него дату начала окна голодания и получаешь дату завершения, время до этого момента и раскладку по зонам, которые предстоит пройти. </p>
<p>Блок показывает актуальную картину каждый раз, когда Obsidian его отрисовывает — то есть, можно следить за своим прогрессом в реальном времени. Когда окно голодания закончится, можно ввести дату завершения и блок покажет результат: получилось ли выполнить цель, сколько времени сверх плана вы голодали и так далее.</p>
<p>Думаю немного доработать визуальную часть (сейчас всё выводится текстом без какого-либо оформления). А ещё — прикрутить функции расчета статистики, чтобы можно было на ходу рисовать красивые графики в духе <a href="https://charts.phib.ro/Meta/Charts/Charts+Documentation" target="_blank">Charts</a> и показывать ачивки. У меня была эта механика в <a href="https://github.com/vkostyanetsky/Fastimer" target="_blank">реализации</a> этого же приложения на Python, но я вряд ли к ней вернусь — в хранилище Obsidian эту задачу решать проще, чем раскатывать на компьютер дополнительную утилиту.</p>
<p>Короче, зацените плагин! :) В библиотеке Обсидиана его можно найти по имени (Fastimer). Или, при желании, установить вручную из репозитория.</p></description>
        </item>
        
    </channel>
</rss>