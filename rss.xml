<rss version="2.0">
    <channel>    
        <title>Влад Костянецкий</title>
        <description>Привет! Меня зовут Влад, я — разработчик приложений для бизнеса.</description>
        <language>ru</language>
        <link>https://kostyanetsky.ru</link>
        <lastBuildDate>Sat, 17 Jan 2026 18:18:43 +0700</lastBuildDate>
        
        <item>
            <title>Новый UI в блоге</title>
            <link>https://kostyanetsky.ru/notes/new-ui</link>
            <guid isPermaLink="false">note-new-ui</guid>
            <pubDate>Sat, 17 Jan 2026 18:18:43 +0700</pubDate>
            <description><p>На новогодних праздниках внезапно закусился и переписал UI блога. Хотел всего-то прикрутить поиск по заметкам: их уже довольно много и время от времени нужно что-то быстро выудить из кучи написанного (например, ссылку коллеге скинуть).</p>
<p>Блог живёт на <a href="https://docs.github.com/ru/pages" target="_blank">Github Pages</a>, так что выбор решений небогат: либо слать запрос в гугл, либо делать свой статический индекс и отдавать в браузер пользователя (пусть сам в нём роется). Я пошёл по второму пути: быстрее, управляемее <s>и можно самому покодить</s>. При первом поиске <a href="https://kostyanetsky.ru/notes.json" target="_blank">файл индекса</a>, правда, нужно скачать, но что такое 200 Кб в современном интернете? Смешно.</p>
<p>Ну а там как-то, знаете ли, пошло-поехало... Сначала не удавалось прикрутить к полю поиска <a href="https://tachyons.io" target="_blank">Tachyons</a> — разозлился и переделал всё на <a href="https://tailwindcss.com" target="_blank">Tailwind</a> (всё равно хотел попробовать, а случая всё никак не представлялось). Пока писал код для поиска — подумал, что логично сразу вкрутить в него теги, чтобы два раза не вставать. Очнулся с облаком тегов над заметками и сообразил, что тогда уж надо и к проектнику что-то в этом духе прикрутить, только там не теги нужны, а стеки...</p>
<p>В общем, получилось как в том меме из «Страха и отвращения в Лас-Вегасе». Сложно было остановиться. Осталось теперь заставить себя писать в новый проектник: работы всегда дофига, и работа интересная, но если не записывать всё — кофе, всё тонет в кофе.</p></description>
        </item>
        
        <item>
            <title>Управление бэкапами</title>
            <link>https://kostyanetsky.ru/notes/backup-ui</link>
            <guid isPermaLink="false">note-backup-ui</guid>
            <pubDate>Sat, 06 Dec 2025 20:57:48 +0700</pubDate>
            <description><p>В конце года выкатили для нашего внутреннего инструмента (я уже вскользь <a href="https://kostyanetsky.ru/notes/easter-eggs" target="_blank">писал</a> о нём) большой апдейт, дающий коллегам адекватный доступ к бэкапам пользовательских приложений. Бэкапы в SaaS-компании нужны всем и всегда — для разработки, для тестирования, для расследования проблем, да много для чего. Без адекватного учёта процесс превращается в зоопарк, когда три человека в один момент времени создают три запроса на практически одинаковые копии одной и той же базы. Задача, конечно, решается, но ресурсов прожрано в три раза больше, чем хотелось бы.</p>
<p>У нас уже было решение на базе UI Битрикса, но в силу, э-э, особенностей развития этого продукта оно приносило больше боли, чем пользы. Поэтому мы переосмыслили процесс и всё переписали. На фронте — 1C, на бэке — PostgREST, PostgreSQL, PowerShell и много чего ещё. Логика довольно сложная, но у пользователя — простой и дружелюбный UI, через который можно заказать бэкап буквально в два нажатия.</p>
<p>Выбрать можно один из трёх видов бэкапов:</p>
<ul>
<li>облачный (копия реального приложения, развёрнутая в облаке и доступная, в том числе, через браузер);</li>
<li>файловый бэкап (обычный .dt-файл, который можно скачать и развернуть на локальной машине);</li>
<li>бэкап конфигурации и расширений (.cf + .cfe).</li>
</ul>
<p>Кроме того, новое решение отслеживает попытки заказать бэкап приложения, если он уже делается прямо сейчас. А ещё — не даёт пользователям бэкапить одно и то же приложение чаще, чем раз в час. </p>
<p>Ну и продолжаем хохмить в интерфейсе, конечно.</p>
<p><img alt="But Still!" src="https://kostyanetsky.ru/notes/backup-ui/but-still.png"/></p>
<p><img alt="Coffee First!" src="https://kostyanetsky.ru/notes/backup-ui/coffee-first.png"/></p></description>
        </item>
        
        <item>
            <title>Протоптанные дорожки</title>
            <link>https://kostyanetsky.ru/notes/desire-paths</link>
            <guid isPermaLink="false">note-desire-paths</guid>
            <pubDate>Sat, 29 Nov 2025 21:00:48 +0700</pubDate>
            <description><p>Ладно, загадка Жана Фреско. У вас есть таблица, скажем, на 50 тысяч строк. Как прочитать из неё полмиллиарда?</p>
<p>Раз плюнуть, Nested Loops + Clustered Index Seek:</p>
<p><img alt="Полмиллиарда" src="https://kostyanetsky.ru/notes/desire-paths/500_million.png"/></p>
<p>От Clustered Index Seek тут одно название, конечно. Фактически оператор при каждом исполнении пробегает по всей таблице (всему кластерному индексу) и сверяет каждую запись с Predicates. И так — 10 730 раз для 51 391 записей. В итоге 551 425 430 строк прочитали, 13 343 вернули.</p>
<p><img alt="Ох" src="https://kostyanetsky.ru/notes/desire-paths/ouch.gif"/></p>
<p>Короче, идеальный пример плохого плана запроса в вакууме, хоть сейчас тащи в палату мер и весов. Nested Loops, если кто позабыл, работает примерно так:</p>
<pre>
For Each Table1Row In Table1 Do
    For Each Table2Row In Table2 Do
        ...
</pre>
<p>Это ОК для мелких таблиц, но СУБД может его применить и для таблиц поболбше — например, если ей не хватает времени на построение плана.</p>
<p>Это и произошло в нашем случае. Прыгнем повыше, на уровень платформы: тут у нас динамический список с запросом по таблице документа, к которой разработчики прицепили с десяток виртуальных таблиц регистров накопления.</p>
<p>Некоторые регистры и сами по себе были здоровенными, а виртуальные таблицы дополнительно поддали жару (каждая превращается в 2+ вложенных запроса). СУБД честно пыталась придумать эффективный алгоритм, но в какой-то момент решала, что хреновый план запроса всё же лучше, чем вообще никакого.</p>
<p>В итоге пользователь что? Пытался поискать документ по номеру и клиентское приложение просто-напросто зависало.</p>
<p>Короче, по поводу виртуальных таблиц в динамических списках. В английском есть выражение «desire path», «протоптанная дорожка». Часто прицепить виртуальную таблицу к основной — и в самом деле самый простой, быстрый и привычный способ решить задачу. Но он <strong>не эффективен</strong>.</p>
<p>Есть, например, обработчик <code>ПриПолученииДанныхНаСервере()</code>. Он дольше в реализации, но позволяет хорошо затюнить виртуальную таблицу и избежать сценария выше. На каждую прокрутку списка получится больше запросов, но они будут быстрее и эффективнее, чем один, но гигантский.</p></description>
        </item>
        
        <item>
            <title>Дневник питания в Obsidian Bases</title>
            <link>https://kostyanetsky.ru/notes/obsidian-foodiary-bases</link>
            <guid isPermaLink="false">note-obsidian-foodiary-bases</guid>
            <pubDate>Sun, 23 Nov 2025 00:01:58 +0700</pubDate>
            <description><p>Переписал с помощью <a href="https://help.obsidian.md/bases" target="_blank">Obsidian Bases</a> свой прошлогодний <a href="https://kostyanetsky.ru/notes/obsidian-foodiary" target="_blank">плагин</a>, считающий калории, белки, жиры и углеводы в пище. Получилось сильно более гибкая и настраиваемая штука, чем в виде плагина — не нужно ничего переписывать, собирать и релизить, если вдруг решил посчитать клетчатку в еде или просто подвигать колонки в отчёте.</p>
<p>Ну и симпатичная, да:</p>
<p><img alt="UI" src="https://kostyanetsky.ru/notes/obsidian-foodiary-bases/base.png"/></p>
<p>Все необходимые настройки и скрипты — в <a href="https://github.com/vkostyanetsky/ObsidianFoodiaryBases" target="_blank">репозитории</a> на Github'е; инструкция <a href="https://github.com/vkostyanetsky/ObsidianFoodiaryBases/blob/main/README.ru.md" target="_blank">переведена</a> на русский язык.</p></description>
        </item>
        
        <item>
            <title>Ну, есть кое-какие</title>
            <link>https://kostyanetsky.ru/notes/well-there-are-some</link>
            <guid isPermaLink="false">note-well-there-are-some</guid>
            <pubDate>Mon, 17 Nov 2025 13:26:00 +0700</pubDate>
            <description><p>Гуляю вечером, сзади идёт какая-то мама и её мелкий — лет пяти, наверное. Я их не вижу, просто слышу разговор. Мама объясняет ребенку про университет: мол, туда надо поступить, учиться, будут экзамены и всё такое.</p>
<p>Мальчик молчит, потом расстроенно выдает:</p>
<p>— Я думал, есть только школа, а оказывается есть ещё сложности...</p></description>
        </item>
        
        <item>
            <title>Безвредный вред</title>
            <link>https://kostyanetsky.ru/notes/harmless-harm</link>
            <guid isPermaLink="false">note-harmless-harm</guid>
            <pubDate>Sun, 16 Nov 2025 10:36:00 +0700</pubDate>
            <description><p>Разбирали на днях с коллегой проблему. Ничего особенно серьёзного, очередное расследование вида «какого черта этот запрос ведет себя странно?».</p>
<p>Упрощая, суть: читаем таблицу базы данных и кладем результат во временную таблицу. Если срабатывает определённое условие, нужно, чтобы временная таблица всё равно создавалась, но была пустой (независимо от того, есть строки в исходной таблице или нет).</p>
<p>Запрос был примерно такой:</p>
<pre>
SELECT
    Table.Field1 AS Field1
FROM
    Table AS Table
WHERE 
    &amp;Parameter
</pre>
<p>Если нужно было отбирать записи из исходной таблицы во временную, в параметр передавался TRUE; если временную таблицу нужно было получить пустой — передавался FALSE.</p>
<p>Несмотря на кажущуюся простоту, такой трюк — проблема для производительности, если таблица, которую читает запрос — большая.</p>
<p>Причина в том, как СУБД работают с параметризованными запросами. И MS SQL, и PostgreSQL строят план выполнения запроса на основе его текста, и в примере выше значение параметра <strong>не</strong> повлияет на принятие решения, нужно читать таблицу или нет.</p>
<p>Таким образом, при выполнении такого запроса обе СУБД педантично прочитают всю таблицу (ну, или её индекс), даже если параметр равен FALSE. В последнем случае каждая прочитанная запись будет отброшена и алгоритм будет работать корректно, однако мы будем тратить ресурсы на бессмысленное чтение данных и забивать буферный кэш, замедляя систему в целом и активно работая на глобальное потепление :)</p>
<p>Решение тут простое — вставлять TRUE/FALSE в тело запроса как константу, не используя параметр. Либо использовать оператор TOP, так текст запроса будет даже проще:</p>
<pre>
SELECT TOP 0
    Table.Field1 AS Field1
FROM
    Table AS Table
</pre>
<p>Тут на уровне SQL мы получим что-то вроде «SELECT TOP 0 ... FROM Table» (для MS SQL) и «SELECT ... FROM Table LIMIT 0» (для PostgreSQL). В итоговом плане будет оператор чтения, но исполнитель фактически не запросит ни одной строки, так что реального сканирования данных не случится (ура).</p>
<p>P.S. Если не критично получать во временной таблице корректные типы колонок, можно вообще вот так:</p>
<pre>
SELECT TOP 0
    UNDEFINED AS Field1
</pre>
<p>Выигрыш в производительности, впрочем, будет таким копеечным, что можно не упарываться. </p></description>
        </item>
        
        <item>
            <title>Шаманство</title>
            <link>https://kostyanetsky.ru/notes/voodoo</link>
            <guid isPermaLink="false">note-voodoo</guid>
            <pubDate>Sun, 05 Oct 2025 23:54:12 +0700</pubDate>
            <description><p>Поймали, кажется, первый воспроизводимый в лабораторных условиях сценарий повреждения кэша платформы. Короткий синопсис:</p>
<ul>
<li>Создаем новое приложение из шаблона 35-го релиза <a href="https://firstbit.ae" target="_blank">нашей ERP</a>.</li>
<li>Запускаем его и ждем, когда закончится инициализация.</li>
<li>Заменяем конфигурацию приложения на 36-й релиз (конкретно, версию 28537 из хранилища разработки) и снова запускаем.</li>
</ul>
<p>После этих нехитрых действий примерно у половины нашей команды платформа перестаёт видеть одно из перечислений. Причем, зараза, избирательно: обращаешься к элементу перечисления на клиенте — полный порядок, обращаешься на сервере — ловишь исключение.</p>
<p>Такая же петрушка с модулем менеджера одного из справочников: его методы недоступны, хотя существуют и объявлены как экспортные. Однако платформа после обновления делает вид, что их нет, и швыряется исключениями при попытке обратиться.</p>
<p><a href="https://x.com/EffinBirds/status/1970264357427704080" target="_blank"><img alt="Welcome To Dipshit Central" src="https://kostyanetsky.ru/notes/voodoo/welcome.jpg"/></a></p>
<p>Как и всегда, когда начинается магия — проблему нужно искать в кэше. Чистишь — все симптомы бесследно исчезают. Кроме того, есть и косвенные признаки:</p>
<ul>
<li>Перечисление было и в 35-м релизе, но было переименовано в 36-м;</li>
<li>Методов в 35-м релизе вообще не было (в 36-м их как раз разработали). </li>
</ul>
<p>То есть не первого, не вторых в кэше 35-го релиза не существовало, а платформа, по какой-то причине, пытается рыться в именно в нём.</p>
<p>Мы пока не доискались, что вызывает сбой. Вышли на конкретный коммит, после которого появилась проблема, но в нём из необычного — одно <a href="https://kostyanetsky.ru/notes/voodoo/the-commit.png" target="_blank">название</a> (и то поблизости есть куда более подозрительные с этой точки зрения <a href="https://kostyanetsky.ru/notes/voodoo/the-other-commit.png" target="_blank">кандидаты</a>). В остальном там минорные <a href="https://kostyanetsky.ru/notes/voodoo/5ba6ac0956e0cc7bc6b520e5110420e6950478fe.diff" target="_blank">изменения</a>, сопровождаемые заменой внутренних идентификаторов объекта метаданных. Они, конечно, связаны с ключами кэша, но их сброс делается при любом изменении любых метаданных и никогда раньше не приводил к проблемам.</p>
<p>Если вы набрели на эту заметку из гугла, потому что столкнулись с той же бедой — закиньте в проблемный объект какую-нибудь правку, чтобы платформа опять сменила идентификаторы объекта метаданных в манифесте. Например, добавьте пустой метод или просто пробел в текст модуля. Это решит проблему с конфигурацией и инструкция в начале заметки перестанет приводить к повреждению кэша.</p>
<p>Шаманство, конечно, но работает ¯\_(ツ)_/¯</p></description>
        </item>
        
        <item>
            <title>Медленное удаление областей Фреша</title>
            <link>https://kostyanetsky.ru/notes/data-history-missing-indexes</link>
            <guid isPermaLink="false">note-data-history-missing-indexes</guid>
            <pubDate>Sun, 03 Aug 2025 16:25:35 +0700</pubDate>
            <description><p>Коллега заметил, что на одном из инстансов нашего фреша удаление областей стало идти прямо-таки трагически долго. Что в метриках? Вот это:</p>
<pre>
DELETE FROM T1
FROM _DataHistoryMetadata T1
WHERE 
    T1._MetadataId = ?
    AND T1._IsActual = 0x00 
    AND NOT (
        T1._MetadataVersionNumber IN (
            SELECT T2._MetadataVersionNumber AS MetadataVersionNumber_
            FROM _DataHistoryVersions T2
            WHERE T2._HistoryDataId IN (
                SELECT DataHistoryLatestVersions1.DataHistoryLatestVersions._HistoryDataId AS HistoryDataId_
                FROM DataHistoryLatestVersions1.DataHistoryLatestVersions T3
                WHERE DataHistoryLatestVersions1.DataHistoryLatestVersions._MetadataId = ?
            )
        )
    )
</pre>
<p>Каждый такой запрос читает порядка двадцати гигабайт. Что тут происходит — примерно понятно: платформа пытается удалить историю данных области и кривой запрос к БД приводит к сканированию всей таблицы по всем областям вместо быстрого поиска по индексу. Кто-то на Дмитровском опять поленился.</p>
<p><a href="https://x.com/EffinBirds/status/1945545263407301033" target="_blank"><img alt="Чему ты удивлён?" src="https://kostyanetsky.ru/notes/data-history-missing-indexes/why.png"/></a></p>
<p>В общем, теряем от тридцати секунд до получаса на действие. Хотелось бы побыстрее. Решение:</p>
<pre>
CREATE NONCLUSTERED INDEX IX_DataHistoryLatestVersions1_MetadataId
  ON dbo._DataHistoryLatestVersions1 (_MetadataId)
  INCLUDE (_HistoryDataId)
  WITH (DROP_EXISTING = OFF, ONLINE = OFF);

CREATE NONCLUSTERED INDEX IX_DataHistoryVersions_MetadataVersionNumber
  ON dbo._DataHistoryVersions (_MetadataVersionNumber)
  WITH (DROP_EXISTING = OFF, ONLINE = OFF);
</pre>
<p>Стоимость удаления области ожидаемо просела на ~99%.</p>
<p>Если будете повторять у себя:</p>
<ol>
<li>Формально такой трюк нарушает лицензионное соглашение, you've been warned и всё такое.</li>
<li>Есть риск, что платформа при будущих реструктуризациях будет спотыкаться о новые индексы (особенно при работе по «новой» схеме). Лучше иметь под рукой готовый скрипт, который сможет их грохнуть, а потом (после реструктуризации) — вернуть обратно.</li>
</ol></description>
        </item>
        
        <item>
            <title>Развенчиватель мифов</title>
            <link>https://kostyanetsky.ru/notes/myth-buster</link>
            <guid isPermaLink="false">note-myth-buster</guid>
            <pubDate>Sun, 27 Jul 2025 12:21:32 +0700</pubDate>
            <description><p>Попался под руку объёмный <a href="https://infostart.ru/1c/articles/2434171/" target="_blank">текст</a> на Инфостарте про мифы о платформе, полез читать.</p>
<p>По сути. Половина там написана заголовка ради, кажется. Свежий номер! Криминал, интриги, расследования! Файловая база быстрее клиент-серверной! СКД медленнее запроса! Вызов метода сервера на сервере — новый вызов сервера! <s>НЛО над Красной площадью!</s></p>
<p>Однако местами и правда любопытно. Например, о том, что код, слепленный в одну строку, механически работает в десять раз быстрее, я услышал впервые. Жалко, за такой отчаянный свэг коллеги побьют быстрее, чем успеешь порадоваться результату. Да и основные тормоза enterprise-приложений чаще растут из других мест.</p>
<p>Или, скажем, сравнение скорости выгрузки в таблицу для представлений объектов и для их наименований. Первое — в десятки раз медленнее! На первый взгляд странно: в конце концов, в обоих случаях у нас строки, и на момент замера они уже извлечены из базы. Думаю, что дело в типизации: строки представлений имеют неограниченную длину, в отличие от наименований. Отсюда расходы на выделение памяти, какие-то вспомогательные структуры и вот мы имеем то, что имеем.</p>
<p>P.S. Про некоторые аспекты из статьи я где-то у себя писал. Если навскидку — помню свою попытку <a href="https://kostyanetsky.ru/notes/is-ref-empty" target="_blank">измерить</a> скорость работы <code>ValueIsFilled()</code> и неприятный <a href="https://kostyanetsky.ru/notes/method-with-surprise" target="_blank">сюрприз</a> от встроенного <code>FindByNumber()</code>.</p></description>
        </item>
        
        <item>
            <title>Удаление геометрии</title>
            <link>https://kostyanetsky.ru/notes/delete-geometry</link>
            <guid isPermaLink="false">note-delete-geometry</guid>
            <pubDate>Thu, 12 Jun 2025 10:40:43 +0700</pubDate>
            <description><p>Освоил прикольный трюк с удалением части объекта в том случае, если он с чем-то пересекается. Например, на этой гифке в центре находится модель головы обезьянки; при движении плоскости видно, как её часть (как раз та, что начинает пересекаться с обезьянкой) исчезает.</p>
<p><img alt="Демо" src="https://kostyanetsky.ru/notes/delete-geometry/demo.gif"/></p>
<p><a href="https://github.com/vkostyanetsky/3DPlayground/blob/main/Geometry%20Nodes/DeleteGeometry.blend" target="_blank">Идея</a> довольно простая: сводим геометрию объекта-ограничителя к кубу, вычисляем его минимальные и максимальные координаты по всем осям, а потом для каждой точки «обрезаемого» объекта проверяем, входит ли она в полученный диапазон. Входит? Удаляем.</p>
<p>Способов применения — масса; например, мне это пригодилось, когда я захотел автоматически отрезать часть линий декоративного нотного стана на стене так, чтобы они не пересекали дверной проем.</p>
<p><img alt="Пример" src="https://kostyanetsky.ru/notes/delete-geometry/case.jpg"/></p>
<p>Конечно, можно было бы сделать это вручную, без геонод, но такой вариант ударил бы по гибкости: изменятся какие-то размеры (ширина стены, размеры двери, угол наклона линий) — всё придётся переделывать.</p></description>
        </item>
        
    </channel>
</rss>